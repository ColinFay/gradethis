---
title: "What do exercise chunks have access to?"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, echo = FALSE}
library(learnr)
```

## Section 1

The best way to reproduce the effects described in this tutorial is to run this code and then work through the tutorial:

```{r eval = FALSE}
foo <- "I was created in the current from which you ran learnr::run_tutorial" # this will be significant

devtools::install_packages("rstudio-education/grader")
learnr::run_tutorial("scoping-rules", package = "grader")
```

### Knitr chunks

Where does knitr save the results of code chunks? In the global environment of a _fresh_ R session. Notice that `foo` does not exist in this session.

```{r}
knitr_obj <- "I was created in a knitr chunk."
environment()
ls.str(environment())
```

### What's in scope?

Which environments are in scope for a learnr exercise chunk? Not the environment above.

Exercise chunks will be evaluated in the R session that calls `learnr::run_tutorial`. Everything in the global environment of that session will be in scope and hence available to the exercise chunk---like `foo`! 

```{r ex, exercise = TRUE}
environment()
parent.env(environment())
ls.str(parent.env(environment()))
foo
```

### The big exception

If a tutorial is launched from the RStudio IDE GUI (by clicking the Run Document button). The exercise chunks will be evaluated in the _fresh_ R process. As a result, everything created by the knitr chunks in the document will be in scope and available to the exercise (which makes a big difference).

To try this, close the tutorial and then run this code and click the Run Document button.

```{r eval = FALSE}
rstudioapi::navigateToFile(system.file("tutorials", "scoping-rules/scoping-rules.Rmd", package = "grader"))
```

